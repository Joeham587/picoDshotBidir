.program dshot_bidir_300

	set pins, 1 [31]  ; output pin should always be high when not sending data for bidir dshot
main_loop:	
    set pindirs, 1 [31] ; set pin to output 
	set pins, 1 [31]
    ; auto-pull enabled
	; pull block ; load 32 bit value into OSR from input fifo, block if no data
    out x, 16 [31] ; load and discard 16 MSB?
	set y, 15 [31] ; y is our loop counter, and we're sending 16 bits
output_loop:	
	out  x, 1  ; grab one byte from OSR, store in x
	jmp !x, emit_0   ; if X==0, go to emit_0
	; fall through to jmp emit_1          ; otherwise, go to emit_1

emit_1:	
	set pins, 0 [23]  ; 0 for high time, since bidir dshot is inverted, and delay 12 cycles
	set pins, 1 [4]  ; 1 for low time, since bidir dshot is inverted
	
	jmp y--, output_loop ; go to output next bit, if we have one y>0
	jmp delay_before_read  ; otherwise we're done outputting and need to delay before read
	
emit_0:	
	set pins, 0 [11]  ; 0 for high time, since bidir dshot is inverted, and delay 6 cycles
	set pins, 1 [16]; 1 for low time, since bidir dshot is inverted, and delay 10 cycles -3
	
	jmp y--, output_loop ; go to output next bit, if we have one y>0
	jmp delay_before_read  ; otherwise we're done outputting and need to delay before read

delay_before_read:   ; delay for 143 cycles total - 1 for pindirs - 1 for bit count
    ; set pins, 1     ; set output back to high
	set x, 7  ; set loop count to 7, resulting in 8 loops
delay_before_read_loop:	
	jmp x--, delay_before_read_loop [31] ; delay+decriment until X is empty
	set pins, 0
	set pindirs, 0 [14] ; set pin to input and delay for 286-8*32-1-1-1-1=26 cycles
	
read:	
	set x, 31  ; bit count (last read is outside loop)
read_first32:	
	; input shift register is all 0s and cleared every PUSH, so no need to set it up
	in pins, 1 [7]  ; read a byte into the input shift register, shifting it left, and delaying 8-1=7 cycles
	jmp x--, read_first32   ; read next bit (if we're still reading bits)
	
    in pins, 1 [5]  ; read final bite, delaying 8 total (in + 5 + push + set)
	push  ; emit the input shift register containing the first 32 samples, clearing the input shift register
	
	set x, 28  ; bit count for remaining 28 samples
read_next28:	
	in pins, 1 [7]  ; read a byte into the input shift register, shifting it left
	jmp x--, read_next28   ; read next bit (if we're still reading bits)
	
	push [31] ; emit the input shift register containing the second 28 samples, clearing the input shift register

	set pindirs, 1 ; output
  	set pins, 1    ; high for bidir

done_loop:
	jmp done_loop  ; just hang here forever

% c-sdk {
static inline void dshot_bidir_300_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = dshot_bidir_300_program_get_default_config(offset);
    sm_config_set_out_pins(&c, pin, 1);
    sm_config_set_in_pins(&c, pin);
    sm_config_set_set_pins(&c, pin, 1);
    // hw_set_bits(&pio->input_sync_bypass, 1u << pin);  // more stable output for some reason
    pio_gpio_init(pio, pin);
    // gpio_set_pulls(pin, false, false);
	gpio_set_drive_strength(pin, GPIO_DRIVE_STRENGTH_2MA);
    sm_config_set_out_shift(&c, false, true, 32);   // auto-pull enabled
    sm_config_set_in_shift(&c, false, false, 32);
    // currently assumes 133Mhz system clock
    sm_config_set_clkdiv(&c, 14);
    pio_sm_init(pio, sm, offset, &c);
}
%}
