.program dshot_bidir_300

.define public BIT_PERIOD 40

.define ONE_HIGH 30
.define ONE_LOW (BIT_PERIOD - ONE_HIGH)
.define ONE_HIGH_DELAY (ONE_HIGH - 1)
.define ONE_LOW_DELAY (ONE_LOW - 5)

.define ZERO_HIGH 15
.define ZERO_LOW (BIT_PERIOD - ZERO_HIGH)
.define ZERO_HIGH_DELAY (ZERO_HIGH - 1)
.define ZERO_LOW_DELAY (ZERO_LOW - 5)

// 8kHz DShot300 -> 1500 frame period -> 1500 - (BIT_PERIOD * 16 + 1) = 859 delay
.define FRAME_DELAY (32 - 2)
.define FRAME_DELAY_COUNT 26
.define FRAME_DELAY_REMAINDER (27 - 5)  // 27 = 859 - 32 * 26

start_frame:
	; set pindirs, 1 [31] ; output
  ; set pins, 0  [31] ; high for bidir
  pull block
  ; mov x, osr
  out y, 16 ; discard 16 most significant bits

check_bit:
  jmp !osre start_bit
  jmp read_delay
start_bit:
  out y, 1
  jmp !y do_zero
do_one:
  set pins, 1 [ONE_HIGH_DELAY]
  set pins, 0 [ONE_LOW_DELAY]
  jmp check_bit
do_zero:
  set pins, 1 [ZERO_HIGH_DELAY]
  set pins, 0 [ZERO_LOW_DELAY]
  jmp check_bit
  

read_delay:   ; delay for a bit less than 30us before read, or 360 cycles
; temp, just write, no read
  jmp start_frame

  ; set pins, 1     ; set output back to high
	set y, 10  ; set loop count to 11, resulting in 12 loops
delay_before_read_loop:	
	jmp y--, delay_before_read_loop [31] ; delay+decriment until X is empty
	; set pins, 0
	set pindirs, 0 [21] ; set pin to input and delay for 360-12*32-1-1-1-1=21 cycles

read:	
	set y, 31  ; bit count (last read is outside loop)
read_first32:	
	; input shift register is all 0s and cleared every PUSH, so no need to set it up
	in pins, 1 [10]  ; read a byte into the input shift register, shifting it left, and delaying 11-1=10 cycles
	jmp y--, read_first32   ; read next bit (if we're still reading bits)
	
  in pins, 1 [8]  ; read final bite, delaying 11 total (in + 8 + push + set)
	push  ; emit the input shift register containing the first 32 samples, clearing the input shift register
	
	set y, 31  ; bit count for remaining 32 samples
read_next32:	
	in pins, 1 [10]  ; read a byte into the input shift register, shifting it left
	jmp y--, read_next32   ; read next bit (if we're still reading bits)
	
	push  ; emit the input shift register containing the second 32 samples, clearing the input shift register
	;jmp start_frame  ; and go back to the main loop to wait for the next output value

	set pindirs, 1 [31] ; output
  set pins, 1  [31] ; high for bidir
;inf_loop:
;  jmp inf_loop

% c-sdk {
static inline void dshot_bidir_300_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = dshot_bidir_300_program_get_default_config(offset);

    sm_config_set_set_pins(&c, pin, 1);
    sm_config_set_in_pins(&c, pin);
    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);
    gpio_set_pulls(pin, true, false);  // up, down

  
    sm_config_set_out_shift(&c, false, false, 32);   // auto-pull enabled
    sm_config_set_in_shift(&c, false, false, 32);

    double clocks_per_us = clock_get_hz(clk_sys) / 1000000;
    // 3.333us per bit for dshot300
    sm_config_set_clkdiv(&c, 3.333 / dshot_bidir_300_BIT_PERIOD * clocks_per_us);

    pio_sm_init(pio, sm, offset, &c);
}
%}